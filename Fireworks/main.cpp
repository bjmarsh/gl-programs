#include <GL/gl.h>
#include <GL/glut.h>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include "../DrawNumbers/numbers.cpp"
#include <unistd.h>

#define SCREENSAVER false
#define PI 3.1415926535898
#define NUM_FW 8                    //number of fireworks on screen at any given time
#define NUM_PARTICLES 100           //maximum number of particles per firework
#define NUM_LAYERS 5                //number of circular layers in the default firework
#define NUM_STARS 300             //maximum number of stars

/*There are 4 different types of fireworks.  3 are listed below, and the default is a circular
  firework consiting of NUM_LAYERS rings of particles.  These can be blinking or non-blinking*/

#define SPIRAL 0                    /* spiral firework generated by the polar equation r=theta */
#define FLOWER 1                    /* flower shaped firework generated by the polar equation 
                                      r=sin(p*theta), where p determines the number of petals */
#define SMILEY 2                    /* smiley shaped firework */

int width=700,height=700;           //width and height of window
float forceGrav=0.5;                //adjusts the downward acceleration of particles due to gravity
float startX=-1,startY;             //initial mouse coordinates
int numStars;                       //number of stars on screen
bool isPaused=false;                //used to pause program
bool dispFPS=false;		    //toggles whether or not the frames per second is displayed
int frame=0,fps;
time_t start,current;

//each particle of firework & each star are of type Particle
class Particle{
      public:
         float x,y,velX,velY,rad,color[3];        // x/y coordinates, vert/horiz velocity, radius and color array [red,green,blue]
         int duration,time;
         int blinkDur;  //the length of time between blinks for a blinking firework
         bool isOn;     //used to tell whether or not to draw particle to screen
         void SetValues(float xt, float yt, float velXt, float velYt, float radt, int blinkDurt, int durationt);
         inline void Draw(float _time,float _duration, float detail);
}stars[NUM_STARS],moon;

class Firework{
      public:
         Particle particles[NUM_PARTICLES];
         int numParticles,particlesLeft,isExploded,duration,height,type;
         float particlesPerLayer[NUM_LAYERS];    //used for default firework to determine the number of particles per circular layer
         bool isBlinking;
         void SetValues(int typet, float x, float y, float velX, float velY, int durationt, int isExplodedt,int heightt);
         void Explode(float speed);
}fireworks[NUM_FW];

void Particle::SetValues(float xt, float yt, float velXt, float velYt, float radt, int blinkDurt, int durationt)
{
   x=xt;
   y=yt;
   velX=velXt;
   velY=velYt;
   rad=radt;
   duration=durationt+rand()%61-30;
   time=duration;
   isOn=true;
   blinkDur=blinkDurt;
   
   //randomly assigns a shade of gray to particle (only affects the stars)
   float colort=rand()%60;
   colort/=100;
   colort+=0.4;
   color[0]=colort;
   color[1]=colort;
   color[2]=colort;
}

inline void Particle::Draw(float _time, float _duration, float detail)
{
     float transparency = (rad>5) ? 0.1 : _time/_duration;   //adjusts transparency based on how long it has been exploded for
     glBegin(GL_POLYGON);
       glColor4f(color[0],color[1],color[2],transparency);
       glVertex2f(x,y);
       glColor4f(color[0],color[1],color[2],0);
       for(float angle=0; angle<=PI+PI/20; angle+=PI/20)
         glVertex2f(rad*cos(angle)+x,rad*sin(angle)+y);
     glEnd();
     glBegin(GL_POLYGON);
       glColor4f(color[0],color[1],color[2],transparency);
       glVertex2f(x,y);
       glColor4f(color[0],color[1],color[2],0);
       for(float angle=PI; angle<=2*PI+PI/20; angle+=PI/20)
         glVertex2f(rad*cos(angle)+x,rad*sin(angle)+y);
     glEnd();
}

//draws rocket before firework explodes
void DrawRocket(float xPos, float yPos)
{
     float length=7;
     for(float y=yPos; y>yPos-length; y--){
        glColor3f(0.5*(1-(yPos-y)/length),0.4*(1-(yPos-y)/length),0);
        glBegin(GL_POINTS);
          glVertex2f(xPos,y);
        glEnd();
     }
}

void Firework::SetValues(int typet, float x, float y, float velX, float velY, int durationt, int isExplodedt,int heightt)
{
     switch(typet){
        case SPIRAL:
             numParticles=40;
             break;
        case FLOWER:
             numParticles=90;
             break;
        case SMILEY:
             numParticles=50;
             break;
        default:
             numParticles=70;
             break;
     }
     particlesLeft=numParticles;
     type=typet;
     isExploded=isExplodedt;
     duration=durationt;
     height=heightt;
     isBlinking=false;
     if(rand()%10==0 && type>2)isBlinking=true;
     for(int i=0; i<=numParticles-1; i++){
        particles[i].SetValues(x,y,velX,velY,4.5,rand()%15+10,durationt);
     }
     float div=0;
     for(float i=0; i<NUM_LAYERS; i++)
       div+=(NUM_LAYERS-i)/NUM_LAYERS;
     for(float i=0; i<NUM_LAYERS; i++)
        particlesPerLayer[(int)i]=round((NUM_LAYERS-i)*numParticles/(div*NUM_LAYERS));
}

void Firework::Explode(float speed)
{
   float red1=(float)(rand()%100)/50;        //2 colors per firework
   float red2=(float)(rand()%100)/50;
   float green1=(float)(rand()%100)/50;  
   float green2=(float)(rand()%100)/50;
   float blue1=(float)(rand()%100)/50;
   float blue2=(float)(rand()%100)/50;
   int currentPart=0;
   float petals=rand()%3+3;                  //adjusts number of petals for the flower firework
   switch(type){ 
    case SPIRAL:
     for(int part=0; part<numParticles; part++){		//part=particle
        float angle=(float)part/(float)numParticles*6*PI;
        float m=tan(angle);
        float nSpeed=angle/6/PI*speed;                          

		/* nSpeed=total speed of particle
		   m=slope of particle's initial trajectory
		   use y=mx and x^2+y^2=nSpeed (pythagorean theorem)
		   to calculate velX and velY
		*/

        particles[part].velX=sqrt(nSpeed*nSpeed/(m*m+1));        
        particles[part].velY=m*particles[part].velX;
        if(cos(angle)<0){		//since slope is always positive, this makes sure that the particles that should go left do go left
          particles[part].velX*=-1;
          particles[part].velY*=-1;
        }
        
        if(nSpeed<(0.5*speed)){      
          particles[part].color[0]=red1;
          particles[part].color[1]=green1;
          particles[part].color[2]=blue1;
       }else{
          particles[part].color[0]=red2;
          particles[part].color[1]=green2;
          particles[part].color[2]=blue2;
       }
     }
     break;
    case FLOWER:
     for(int part=0; part<numParticles; part++){
        float angle=(float)part/(float)numParticles*2*PI;
        float m=tan(angle);
        float nSpeed=speed*sin(petals*angle);
        particles[part].velX=sqrt(nSpeed*nSpeed/(m*m+1));
        particles[part].velY=m*particles[part].velX;
        if(cos(angle)<0){
          particles[part].velX*=-1;
          particles[part].velY*=-1;
        }
        
        if(nSpeed<(0.5*speed)){
          particles[part].color[0]=red1;
          particles[part].color[1]=green1;
          particles[part].color[2]=blue1;
       }else{
          particles[part].color[0]=red2;
          particles[part].color[1]=green2;
          particles[part].color[2]=blue2;
       }
     }
     break;
    case SMILEY:
     for(int part=0; part<numParticles-10; part++){
        float angle=(float)part/(float)(numParticles-10)*2*PI;
        float m=tan(angle);
        particles[part].velX=sqrt(speed*speed/(m*m+1));
        particles[part].velY=m*particles[part].velX;
        if(cos(angle)<0){
          particles[part].velX*=-1;
          particles[part].velY*=-1;
        }
          particles[part].color[0]=red1;
          particles[part].color[1]=green1;
          particles[part].color[2]=blue1;
     }
     speed*=0.65;
     for(int part=numParticles-10; part<numParticles-2; part++){
        float angle=(float)(part-numParticles+10)/4*PI/3+7*PI/6;
        float m=tan(angle);
        particles[part].velX=sqrt(speed*speed/(m*m+1));
        particles[part].velY=m*particles[part].velX;
        if(cos(angle)<0){
          particles[part].velX*=-1;
          particles[part].velY*=-1;
        }
          particles[part].color[0]=red2;
          particles[part].color[1]=green2;
          particles[part].color[2]=blue2;
     }
     speed/=0.65;
     speed*=0.5;
     particles[numParticles-2].velX=sqrt(speed*speed/2);
     particles[numParticles-2].velY=particles[numParticles-2].velX;
     particles[numParticles-1].velX=-sqrt(speed*speed/2);
     particles[numParticles-1].velY=particles[numParticles-2].velX;
     particles[numParticles-2].color[0]=red2;
     particles[numParticles-2].color[1]=green2;
     particles[numParticles-2].color[2]=blue2;
     particles[numParticles-1].color[0]=red2;
     particles[numParticles-1].color[1]=green2;
     particles[numParticles-1].color[2]=blue2;
     break;
    default:
     for(float layer=0; layer<NUM_LAYERS; layer++){
     for(float particle=1; particle<=particlesPerLayer[(int)layer]; particle++){
        float angle=particle/particlesPerLayer[(int)layer]*2*PI;
        float m=tan(angle);
        particles[currentPart].velX=sqrt(speed*speed/(m*m+1));
        particles[currentPart].velY=m*particles[currentPart].velX;
        if(cos(angle)<0)particles[currentPart].velX*=-1;
        
       m=NUM_LAYERS-layer;
       m/=NUM_LAYERS;
       m+=(float)(rand()%7-3)/100;
       
       if(m<0.75){
          particles[currentPart].color[0]=red1;
          particles[currentPart].color[1]=green1;
          particles[currentPart].color[2]=blue1;
       }else{
          particles[currentPart].color[0]=red2;
          particles[currentPart].color[1]=green2;
          particles[currentPart].color[2]=blue2;
       }
        
      particles[currentPart].velX*=m;
      particles[currentPart].velY*=m;
      currentPart++;
     }
     }
     break;
   }
     isExploded=1;
     if(isBlinking){
        for(int part=0; part<numParticles; part++){
            particles[part].color[0]=1;
            particles[part].color[1]=1;
            particles[part].color[2]=1;
            particles[part].duration*=2;
            particles[part].time*=2;
        }
     }
}

void init() 
{
   glClearColor (0.0, 0.0, 0.0, 0.0);
   glClear(GL_COLOR_BUFFER_BIT);
   glEnable (GL_BLEND);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glShadeModel (GL_SMOOTH);
   glPointSize(3);
   glEnable(GL_POINT_SMOOTH);
   srand (time(NULL));
   numStars=NUM_STARS;
   time(&start);
}

void display(void)
{
   //clear the screen
   glClear(GL_COLOR_BUFFER_BIT);
   
   //draw the stars to the screen
   for(int a=0; a<numStars; a++)
      stars[a].Draw(1,1,8);
   
   moon.Draw(1,1,40);
   glColor4f(0.7,0.7,0.7,1);
   glBegin(GL_POLYGON);
     for(float angle=0; angle<=2*PI; angle+=PI/20)
       glVertex2f(moon.rad*0.2*cos(angle)+moon.x,moon.rad*0.2*sin(angle)+moon.y);
   glEnd();
   
   //Goes through each particle of each firework & calculates new position and velocity and draws to screen
   for(int a=0; a<NUM_FW; a++){
   for(int i=0; i<=fireworks[a].numParticles-1; i++){
           
     //calculates new position of particle      
     fireworks[a].particles[i].y+=fireworks[a].particles[i].velY;
     fireworks[a].particles[i].x+=fireworks[a].particles[i].velX;
     
     //slows velocity once exploded so particles don't shoot off the screen
     fireworks[a].particles[i].velX*=0.94;
     if(fireworks[a].isExploded)fireworks[a].particles[i].velY*=0.94;
     
     //gravity acts on particles after firework explodes
     if(fireworks[a].isExploded)fireworks[a].particles[i].velY-=forceGrav/100;
     
     //if firework is a blinking firework, this makes the particles turn on and off
     if(fireworks[a].isBlinking && fireworks[a].particles[i].time%fireworks[a].particles[i].blinkDur==0){
       fireworks[a].particles[i].isOn=!fireworks[a].particles[i].isOn;
       fireworks[a].particles[i].blinkDur=rand()%15+15;
     }
     
     //if firework is exploded and particle is on, then this draws the particle to the screen
     if(fireworks[a].particles[i].isOn && fireworks[a].isExploded)
       fireworks[a].particles[i].Draw(fireworks[a].particles[i].time,fireworks[a].particles[i].duration,8);
     //this draws the rocket if firework is not exploded
     else if(fireworks[a].particles[i].isOn)
       DrawRocket(fireworks[a].particles[i].x,fireworks[a].particles[i].y);
     
     //explodes firework once it reaches its maximum height
     if((fireworks[a].particles[i].y>=fireworks[a].height)&&(!fireworks[a].isExploded))fireworks[a].Explode(rand()%10+6);
     
     //adjusts the length of time the particle has been exploded for, and if gone, it decrements the number of particles left in the firework
     if(fireworks[a].isExploded)fireworks[a].particles[i].time--;
     if(fireworks[a].particles[i].time==0)fireworks[a].particlesLeft--;
   }
   //once firework is gone, this makes it a new rocket
   if(fireworks[a].particlesLeft==0)fireworks[a].SetValues(rand()%5,rand()%width,0,0,rand()%5+2,rand()%80+150,0,rand()%(height-200)+200);
   }
   time(&current);
   frame++;
   if(current!=start){
      fps=frame;
      frame=0;
      time(&start);
   }
   //displays fps in lower left corner
   if(dispFPS)DrawIntL(fps,7,20,14,7,1,1,1);
   glutSwapBuffers();
}

void reshape (int w, int h)
{
   glViewport (0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode (GL_PROJECTION);
   glLoadIdentity ();
   gluOrtho2D (0.0, (GLdouble) w, 0.0, (GLdouble) h);
   width=w;
   height=h;
   //set initial values of fireworks
   for(int i=0; i<NUM_FW; i++)
      fireworks[i].SetValues(rand()%5,rand()%width,0,0,rand()%5+2,rand()%80+150,0,rand()%(height-200)+200);
   //generates stars
   for(int i=0; i<NUM_STARS; i++)
      stars[i].SetValues(rand()%width,rand()%height,0,0,rand()%3+1,0,1);
   moon.SetValues(rand()%(width-100)+50,height-50,0,0,rand()%100+275,0,0);
}

void idle()
{
     if(!isPaused)
       glutPostRedisplay();
     usleep(4000);
}

void keyboard(unsigned char key, int x, int y)
{
     switch(key){
        case 27:
             exit(0);
             break;
        case 'p':
        case 'P':
             isPaused=!isPaused;
             break;
        case 's':
        case 'S':
             dispFPS=!dispFPS;
             break;
     }
}

//if in screensaver mode, this detects mouse movement and closes the program
void passive(int x, int y)
{
     if(startX==-1){
       startX=x;
       startY=y;
     }else{
       if(abs(x-startX)>=4 || abs(y-startY)>=4)
       exit(0);
     }
}

int main(int argc, char** argv)
{
   glutInit(&argc, argv);
   glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);
   glutInitWindowSize (700, 700); 
   glutInitWindowPosition (0, 0);
   glutCreateWindow ("Fireworks");
   glutFullScreen();
   glutSetCursor(GLUT_CURSOR_NONE);
   init();
   glutDisplayFunc(display); 
   glutReshapeFunc(reshape);
   glutIdleFunc(idle);
   glutKeyboardFunc(keyboard);
   if(SCREENSAVER)glutPassiveMotionFunc(passive);
   glutMainLoop();
   return 0;
}
